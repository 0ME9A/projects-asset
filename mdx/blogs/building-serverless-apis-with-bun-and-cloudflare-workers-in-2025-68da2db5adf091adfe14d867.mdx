---
title: "Building Serverless APIs with Bun and Cloudflare Workers in 2025"
description: "Learn to build efficient serverless APIs using Bun and Cloudflare Workers in 2025. This comprehensive guide covers setup, routing, deployment, and optimization, leveraging the latest JavaScript runtime and edge computing for scalable applications."
keywords: "serverless APIs, Bun runtime, Cloudflare Workers, 2025 web dev, edge computing, JavaScript, API optimization"
seoKeywords: "serverless tutorial, Bun development, Cloudflare Workers, 2025 tech, edge API design"
category: "Serverless"
---

# Building Serverless APIs with Bun and Cloudflare Workers in 2025

In 2025, serverless architecture is dominating the web development landscape, and the combination of Bun—a fast, all-in-one JavaScript runtime—and Cloudflare Workers—an edge computing platform—is revolutionizing API creation. For developers seeking lightweight, scalable solutions, this duo offers a modern alternative to traditional Node.js setups. This in-depth guide explores building serverless APIs with Bun and Cloudflare Workers, covering setup, routing, deployment, and optimization to empower your projects in today’s edge-driven world.

## Why Bun and Cloudflare Workers in 2025?

The rise of Bun and Cloudflare Workers in 2025 is driven by performance and scalability needs. Bun, released with a focus on speed, outpaces Node.js in startup times and package management, while Cloudflare Workers leverage global edge networks for low-latency API responses. Key benefits include:
- **Speed**: Bun’s JIT compiler and native bundler accelerate development.
- **Scalability**: Cloudflare’s edge deployment handles millions of requests effortlessly.
- **Cost-Efficiency**: Pay-per-use pricing beats traditional server costs.
- **Ecosystem Growth**: Bun’s compatibility with npm and Workers’ KV storage align with 2025 trends.

## Setting Up Bun and Cloudflare Workers

### Installing Bun
Get Bun running on your system:
- **Code** (Linux/Mac):
  ```bash
  curl -fsSL https://bun.sh/install | bash
  bun --version
  ```
- **Explanation**: Downloads and installs Bun, verifying the version (e.g., 1.1.0+ in 2025).

### Cloudflare Account and Wrangler
Set up Cloudflare Workers with Wrangler:
- **Code**:
  ```bash
  npm install -g wrangler
  wrangler login
  ```
- **Explanation**: Installs Wrangler CLI and logs into your Cloudflare account.

### Project Structure
Organize your API project:
```
serverless-api/
  ├── src/              # API logic
  ├── package.json
  ├── wrangler.toml     # Cloudflare config
```

## Building the API with Bun

### Initializing the Project
Create a new Bun project:
- **Code**:
  ```bash
  bun init -y
  bun add @cloudflare/workers-types
  ```
- **Explanation**: Sets up a project with TypeScript support for Workers.

### Basic API Endpoint
Create a simple API handler:
- **Code** (src/index.ts):
  ```typescript
  // src/index.ts
  export default {
    async fetch(request: Request): Promise<Response> {
      const url = new URL(request.url);
      if (url.pathname === '/api/hello') {
        return new Response(JSON.stringify({ message: 'Hello from Bun!' }), {
          headers: { 'Content-Type': 'application/json' },
        });
      }
      return new Response('Not Found', { status: 404 });
    },
  };
  ```
- **Explanation**: Defines a basic `/api/hello` endpoint using Bun’s fetch handler.

### Adding Routes
Implement dynamic routing:
- **Code** (src/index.ts):
  ```typescript
  // src/index.ts
  export default {
    async fetch(request: Request): Promise<Response> {
      const url = new URL(request.url);
      const { pathname } = url;

      if (pathname === '/api/hello') {
        return new Response(JSON.stringify({ message: 'Hello from Bun!' }), {
          headers: { 'Content-Type': 'application/json' },
        });
      }

      if (pathname.startsWith('/api/user/')) {
        const id = pathname.split('/').pop();
        return new Response(JSON.stringify({ id, status: 'active' }), {
          headers: { 'Content-Type': 'application/json' },
        });
      }

      return new Response('Not Found', { status: 404 });
    },
  };
  ```
- **Explanation**: Adds a `/api/user/:id` route for dynamic user data.  
  > **Note on Complex Routing**: For larger APIs, manual `if/else` routing can become unmanageable. Many developers use lightweight libraries like Hono or itty-router, optimized for the Workers environment, offering cleaner code and middleware support.

## Integrating with Cloudflare Workers

### Configuring wrangler.toml
Set up Cloudflare deployment:
- **Code** (wrangler.toml):
  ```toml
  name = "serverless-api"
  main = "src/index.ts"
  compatibility_date = "2025-09-26"
  ```
- **Explanation**: Configures the Worker with the entry point and current date.

### Testing Locally
Run the API locally:
- **Code**:
  ```bash
  bun --watch src/index.ts
  # Or with Wrangler
  wrangler dev
  ```
- **Explanation**: Uses Bun’s watch mode or Wrangler for local testing.

### Deploying to Cloudflare
Deploy the API:
- **Code**:
  ```bash
  wrangler publish
  ```
- **Explanation**: Pushes the Worker to Cloudflare’s edge network.


## Also Read
- [Exploring the Juris Framework: A New JavaScript Contender](https://ome9a.com/blogs/exploring-the-juris-framework-a-new-javascript-contender-july-2025-687cccb4db71d0f817e2cc5e)
- [Revamping MERN Workflows with AI Tools in 2025](https://ome9a.com/blogs/revamping-mern-workflows-with-ai-tools-in-2025-68d39831d2cce25fff27fc02)
- [Deploying MERN Apps with Docker in 2025](https://ome9a.com/blogs/deploying-mern-apps-with-docker-in-2025-68d4ef5b6dfbca526c4c1e11)


## Optimizing Serverless APIs

### Using KV Storage
Add persistent data with Cloudflare KV:
- **Code** (src/index.ts):
  ```typescript
  // src/index.ts
  import { KVNamespace } from '@cloudflare/workers-types';

  interface Env {
    MY_KV: KVNamespace;
  }

  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const url = new URL(request.url);
      if (url.pathname === '/api/set') {
        await env.MY_KV.put('key', 'value');
        return new Response('Value set', { status: 200 });
      }
      if (url.pathname === '/api/get') {
        const value = await env.MY_KV.get('key');
        return new Response(JSON.stringify({ value }), {
          headers: { 'Content-Type': 'application/json' },
        });
      }
      return new Response('Not Found', { status: 404 });
    },
  };
  ```
- **Code** (wrangler.toml):
  ```toml
  [env.production]
  kv_namespaces = [{ binding = "MY_KV", id = "YOUR_KV_ID" }]
  ```
- **Explanation**: Integrates KV for key-value storage, configurable via Wrangler.

### Rate Limiting
Enhance security with reliable limits:
- **Explanation**: The most robust rate limiting on the edge should leverage Cloudflare's dedicated Rate Limiting service, or implement shared state using Durable Objects or KV storage for consistency across the global network. This ensures reliable request management, avoiding the pitfalls of in-memory solutions that reset with instance changes.

### Caching Responses
Leverage edge caching:
- **Code** (src/index.ts):
  ```typescript
  // src/index.ts
  export default {
    async fetch(request: Request): Promise<Response> {
      const url = new URL(request.url);
      if (url.pathname === '/api/hello') {
        const cache = caches.default;
        const cachedResponse = await cache.match(request);
        if (cachedResponse) return cachedResponse;

        const response = new Response(JSON.stringify({ message: 'Hello from Bun!' }), {
          headers: { 'Content-Type': 'application/json', 'Cache-Control': 's-maxage=60' },
        });
        await cache.put(request, response.clone());
        return response;
      }
      return new Response('Not Found', { status: 404 });
    },
  };
  ```
- **Explanation**: Uses Cloudflare’s cache API for a 60-second edge cache.

## Real-World Example: Task Management API

Build a task API:
- **Code** (src/index.ts):
  ```typescript
  // src/index.ts
  interface Env {
    MY_KV: KVNamespace;
  }

  interface Task {
    id: string;
    title: string;
    completed: boolean;
  }

  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const url = new URL(request.url);
      const { pathname, method } = url;

      if (pathname === '/api/tasks' && method === 'POST') {
        const { title } = await request.json();
        const id = crypto.randomUUID();
        const task: Task = { id, title, completed: false };
        await env.MY_KV.put(`task:${id}`, JSON.stringify(task));
        return new Response(JSON.stringify(task), {
          headers: { 'Content-Type': 'application/json' },
        });
      }

      if (pathname === '/api/tasks' && method === 'GET') {
        const tasks = [];
        for await (const [key, value] of env.MY_KV.list({ prefix: 'task:' })) {
          tasks.push(JSON.parse(value));
        }
        return new Response(JSON.stringify(tasks), {
          headers: { 'Content-Type': 'application/json' },
        });
      }

      return new Response('Not Found', { status: 404 });
    },
  };
  ```
- **Explanation**: Implements CRUD for tasks, storing data in KV.

## Best Practices for 2025

- **Type Safety**: Use TypeScript for robust APIs.
- **Error Handling**: Implement global error catching.
- **Monitoring**: Use Cloudflare Analytics for performance insights.
- **Security**: Enable Workers’ built-in WAF for protection.

## Challenges

- **Learning Curve**: Bun and Workers require adapting to new paradigms.
- **Cold Starts**: Initial latency can occur with infrequent use.
- **Limits**: KV storage and request quotas need careful management.

## Conclusion
Building serverless APIs with Bun and Cloudflare Workers in 2025 offers a fast, scalable solution for modern web apps. By mastering setup, routing, and optimization, you can harness edge computing to deliver low-latency APIs. Dive into this approach to stay ahead in the serverless revolution.

**Call to Action**: Hey, it’s Baliram Singh! Build your serverless API with Bun and share your code on X at [@omegaStrikes](https://x.com/omegaStrikes) with #BunServerless. More on ome9a.com!